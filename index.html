<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Media</title>
  <meta name="referrer" content="no-referrer-when-downgrade">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@1.6.15/dist/hls.min.js"></script>
  <!-- 预加载关键资源 -->
  <link rel="preconnect" href="https://cdn.jsdelivr.net">
  <link rel="preconnect" href="https://apiv.nyanx.de" crossorigin>
  <!-- 移动端优化 -->
  <meta name="format-detection" content="telephone=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <style>
    :root {
      --yt-red: #ff0000;
      --bg-dark: #000000;
      --panel-bg: rgba(28, 28, 28, 0.95);
      --border-light: rgba(255, 255, 255, 0.1);
      --ease-click: cubic-bezier(0.4, 0, 0.2, 1);
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      height: 100dvh;
      width: 100%;
      background: var(--bg-dark);
      color: #fff;
      font-family: -apple-system, sans-serif;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* 搜索栏 */
    .search-container {
      flex: 0 0 auto;
      padding: calc(env(safe-area-inset-top, 0px) + 15px) 20px 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
      z-index: 1000;
    }

    .search-box {
      display: flex;
      align-items: center;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 6px 16px;
      width: 100%;
      max-width: 500px;
      border: 1px solid var(--border-light);
    }

    .search-box input {
      background: transparent;
      border: none;
      color: #fff;
      font-size: 15px;
      padding: 4px 0;
      width: 100%;
      outline: none;
    }

    .search-box svg {
      fill: rgba(255, 255, 255, 0.5);
      margin-right: 10px;
      flex-shrink: 0;
    }

    .search-results-overlay {
      position: absolute;
      top: 65px;
      width: calc(100% - 40px);
      max-width: 500px;
      background: var(--panel-bg);
      backdrop-filter: blur(25px);
      -webkit-backdrop-filter: blur(25px);
      border: 1px solid var(--border-light);
      border-radius: 12px;
      max-height: 350px;
      overflow-y: auto;
      display: none;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.9);
      animation: fadeIn 0.2s ease-out;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-5px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .result-item {
      padding: 15px 20px;
      border-bottom: 1px solid var(--border-light);
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }

    .result-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .result-item b {
      color: var(--yt-red);
    }

    .main-player-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 0 20px;
    }

    .player-stabilizer {
      width: 100%;
      max-width: 860px;
      display: flex;
      flex-direction: column;
    }

    #videoTitle {
      font-size: 11px;
      font-weight: 700;
      color: rgba(255, 255, 255, 0.4);
      text-transform: uppercase;
      letter-spacing: 1.5px;
      text-align: center;
      margin-bottom: 10px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .video-wrapper {
      position: relative;
      background: #000;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
      aspect-ratio: 16 / 9;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      /* 防止拖拽时的缩放和滚动 */
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-user-drag: none;
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      /* 移动端渲染优化 */
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
      will-change: transform;
      /* 硬件加速 */
      -webkit-backface-visibility: hidden;
      -webkit-perspective: 1000;
      backface-visibility: hidden;
      perspective: 1000;
      /* 防止拖拽进度条时视频缩放 */
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-user-drag: none;
    }

    .controls-panel {
      width: 100%;
      background: var(--panel-bg);
      backdrop-filter: blur(25px);
      -webkit-backdrop-filter: blur(25px);
      padding: 16px;
      margin-top: 15px;
      border-radius: 20px;
      border: 1px solid var(--border-light);
    }

    .progress-wrapper {
      width: 100%;
      height: 20px;
      display: flex;
      align-items: center;
      cursor: pointer;
      touch-action: none;
    }

    .progress-container {
      width: 100%;
      height: 5px;
      background: rgba(255, 255, 255, 0.1);
      position: relative;
      border-radius: 3px;
      overflow: hidden;
    }

    .progress-buffer {
      position: absolute;
      height: 100%;
      background: rgba(255, 255, 255, 0.15);
    }

    .progress-bar {
      height: 100%;
      background: var(--yt-red);
      width: 0%;
      position: relative;
    }

    .seek-row {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      margin: 10px 0 15px;
    }

    .seek-btn {
      background: rgba(255, 255, 255, 0.08);
      border: none;
      color: #bbb;
      padding: 10px 0;
      font-size: 10px;
      border-radius: 10px;
      font-weight: 700;
      transition: all 0.1s var(--ease-click);
    }

    .seek-btn:active {
      transform: scale(0.92);
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    .bottom-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 40px;
    }

    .btn-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .btn {
      background: transparent;
      border: none;
      color: #fff;
      cursor: pointer;
      padding: 5px;
      display: flex;
      align-items: center;
      transition: 0.1s;
    }

    .btn:active {
      transform: scale(0.85);
      opacity: 0.7;
    }

    .btn svg {
      width: 24px;
      height: 24px;
      fill: currentColor;
    }

    #volSlider {
      -webkit-appearance: none;
      appearance: none;
      width: 70px;
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      outline: none;
      cursor: pointer;
    }

    #volSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      background: #fff;
      border-radius: 50%;
    }

    #volSlider::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: #fff;
      border-radius: 50%;
      border: none;
    }

    #volSlider::-moz-range-track {
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
    }

    /* 移动端隐藏音量条 */
    @media (max-width: 768px) {
      #volSlider {
        display: none !important;
      }

      .btn-group {
        gap: 8px;
      }
    }

    #timeBox {
      font-size: 12px;
      color: #999;
      font-variant-numeric: tabular-nums;
    }

    #speedBtn {
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 2px 8px;
      font-size: 11px;
    }

    .state-overlay {
      position: absolute;
      pointer-events: none;
      z-index: 10;
    }

    .center-btn {
      width: 66px;
      height: 66px;
      background: rgba(255, 0, 0, 0.9);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top-color: var(--yt-red);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .speed-menu {
      position: absolute;
      bottom: 60px;
      right: 0;
      background: #222;
      border-radius: 14px;
      display: none;
      flex-direction: column;
      border: 1px solid #333;
      z-index: 100;
      overflow: hidden;
    }

    .speed-menu.show {
      display: flex;
    }

    .speed-item {
      padding: 12px 25px;
      font-size: 13px;
      cursor: pointer;
      text-align: center;
      border-bottom: 1px solid #333;
    }

    .speed-item.active {
      color: var(--yt-red);
      background: #2a2a2a;
    }

    .hidden {
      display: none !important;
    }

    /* 控制面板样式 */
    .controls-panel {
      width: 100%;
      background: var(--panel-bg);
      backdrop-filter: blur(25px);
      -webkit-backdrop-filter: blur(25px);
      padding: 16px;
      margin-top: 15px;
      border-radius: 20px;
      border: 1px solid var(--border-light);
    }
  </style>
</head>

<body>
  <div class="search-container">
    <div class="search-box">
      <svg viewBox="0 0 24 24" width="20" height="20">
        <path
          d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" />
      </svg>
      <input type="text" id="searchInput" placeholder="输入关键词搜索..." autocomplete="off">
    </div>
    <div id="resultsList" class="search-results-overlay"></div>
  </div>

  <div class="main-player-area">
    <div class="player-stabilizer" id="playerNode">
      <div id="videoTitle">READY</div>

      <div class="video-wrapper" id="screen">
        <video id="video" playsinline webkit-playsinline></video>
        <div class="state-overlay">
          <div class="center-btn" id="centerPlayIcon">
            <svg viewBox="0 0 24 24" width="32" height="32" fill="white">
              <path d="M8 5v14l11-7z" />
            </svg>
          </div>
          <div id="loader" class="hidden">
            <div class="spinner"></div>
          </div>
        </div>
      </div>

      <div class="controls-panel">
        <div class="progress-wrapper" id="progressWrap">
          <div class="progress-container">
            <div class="progress-buffer" id="bufferBar"></div>
            <div class="progress-bar" id="progressBar"></div>
          </div>
        </div>

        <div class="seek-row">
          <button class="seek-btn" onclick="window.seek(-600)">-10m</button>
          <button class="seek-btn" onclick="window.seek(-60)">-1m</button>
          <button class="seek-btn" onclick="window.seek(-10)">-10s</button>
          <button class="seek-btn" onclick="window.seek(10)">+10s</button>
          <button class="seek-btn" onclick="window.seek(60)">+1m</button>
          <button class="seek-btn" onclick="window.seek(600)">+10m</button>
        </div>

        <div class="bottom-row">
          <div class="btn-group">
            <button class="btn" id="playBtn">
              <svg id="pIcon" viewBox="0 0 24 24">
                <path d="M8 5v14l11-7z" />
              </svg>
            </button>
            <button class="btn" id="nextBtn">
              <svg viewBox="0 0 24 24">
                <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z" />
              </svg>
            </button>
            <div class="btn-group">
              <button class="btn" id="volBtn"><svg id="vIcon" viewBox="0 0 24 24"></svg></button>
              <input type="range" id="volSlider" min="0" max="1" step="0.01" value="0.5">
            </div>
            <span id="timeBox">0:00 / 0:00</span>
          </div>

          <div class="btn-group" style="position: relative;">
            <div class="speed-menu" id="speedMenu">
              <div class="speed-item" data-val="0.5">0.5x</div>
              <div class="speed-item active" data-val="1.0">1.0x</div>
              <div class="speed-item" data-val="1.5">1.5x</div>
              <div class="speed-item" data-val="2.0">2.0x</div>
            </div>
            <button class="btn" id="speedBtn">1.0x</button>
            <button class="btn" id="pipBtn">
              <svg viewBox="0 0 24 24">
                <path
                  d="M19 11h-8v6h8v-6zm4 8V4.98C23 3.88 22.1 3 21 3H3c-1.1 0-2 .88-2 1.98V19c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H3V4.97h18v14.05z" />
              </svg>
            </button>
            <button class="btn" id="fullBtn">
              <svg viewBox="0 0 24 24">
                <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3z" />
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const $ = id => document.getElementById(id);
    const video = $('video'), bar = $('progressBar'), buf = $('bufferBar'), wrap = $('progressWrap');
    const volSlider = $('volSlider'), volBtn = $('volBtn'), searchInput = $('searchInput'), resultsList = $('resultsList');

    let hls = null, isDragging = false, isLoaded = false;
    let usedCodes = [];
    const API = "https://apiv.nyanx.de/";
    let wakeLock = null;

    // 移动端网络状况检测
    function getNetworkQuality() {
      // 使用 Network Information API 检测网络状况
      if ('connection' in navigator) {
        const connection = navigator.connection;
        const effectiveType = connection.effectiveType || 'unknown';
        const downlink = connection.downlink || 0;

        if (effectiveType === 'slow-2g' || effectiveType === '2g') {
          return 'poor';
        } else if (effectiveType === '3g' || downlink < 1.5) {
          return 'moderate';
        } else if (effectiveType === '4g' || downlink >= 1.5) {
          return 'good';
        }
      }

      // 如果不支持 Network Information API，返回默认值
      return 'unknown';
    }

    // 根据网络状况调整HLS配置
    function getHlsConfigForNetwork(networkQuality) {
      const baseConfig = {
        // 缓冲区优化 - 优化卡顿问题
        backBufferLength: 90, // 增加后缓冲区，减少卡顿
        maxBufferLength: 90, // 增加最大缓冲区长度，提高流畅度 (减少延迟)
        maxMaxBufferLength: 120, // 最大缓冲区长度上限
        // 加载策略 - 优化卡顿问题
        liveSyncDurationCount: 6, // 适中同步片段数，平衡延迟和稳定性
        liveMaxLatencyDurationCount: 12, // 设置最大延迟片段数
        maxLoadingDelay: 6, // 增加加载延迟，避免频繁加载
        maxStarvationDelay: 6, // 增加饥饿延迟，减少卡顿
        // 自适应码率 - 针对卡顿问题优化
        abrEwmaFastLive: 3.0, // 调整快速带宽估算时间常数，更平滑切换
        abrEwmaSlowLive: 10.0, // 调整慢速带宽估算时间常数，避免频繁切换
        abrEwmaDefaultEstimate: 5e5, // 默认带宽估算 (500 kbps)
        abrBandWidthFactor: 0.8, // 带宽使用因子
        abrBandWidthUpFactor: 0.75, // 上调带宽因子，更保守
        // 性能优化
        enableWorker: true, // 使用web worker解码，减少主线程阻塞
        workerPath: null, // 使用默认worker路径
        enableWebWorker: true,
        lowLatencyMode: false, // 关闭低延迟模式，提高稳定性
        progressive: true, // 启用渐进式下载
        // 关键帧对齐
        forceKeyFrameOnDiscontinuity: true,
        // 网络请求优化
        maxBufferHole: 0.01, // 减小缓冲间隙，提高连续性
        highBufferWatchdogPeriod: 3, // 增加高缓冲监控周期
        nudgeMaxRetry: 5, // 增加同步重试次数
        maxFragLookUpTolerance: 0.005, // 减小片段查找容差
        // 优化加载行为
        startFragPrefetch: true, // 预加载第一个片段
        testBandwidth: true, // 测试带宽以选择合适的质量
        // 错误处理优化
        nudgeOffset: 0.05, // 减小调整同步偏移
        nudgeRetry: 6, // 调整重试次数
        // 启用网络优化
        xhrSetup: function (xhr, url) {
          // 允许跨域请求，添加移动端网络优化
          xhr.withCredentials = false;
          // 设置请求超时时间
          xhr.timeout = 30000; // 30秒超时，给更多时间加载
        },
        // 启用后处理以优化性能
        fragLoadingTimeOut: 30000, // 片段加载超时
        fragLoadingMaxRetry: 10, // 片段加载最大重试次数
        fragLoadingMaxRetryTimeout: 120000, // 片段加载最大重试超时
        levelLoadingTimeOut: 30000, // 级别加载超时
        levelLoadingMaxRetry: 10, // 级别加载最大重试次数
        levelLoadingMaxRetryTimeout: 120000, // 级别加载最大重试超时
        // 其他优化参数
        maxBufferSize: 100 * 1000 * 1000, // 最大缓冲区大小 100MB
        appendErrorMaxRetry: 6, // 追加错误最大重试次数
        enableSoftwareAES: true, // 启用软件AES解密
        manifestLoadingTimeOut: 30000, // 清单加载超时
        manifestLoadingMaxRetry: 6, // 清单加载最大重试次数
        manifestLoadingMaxRetryTimeout: 120000, // 清单加载最大重试超时
        levelLoadingLoadPolicy: { // 级别加载策略
          default: {
            maxTimeToFirstByte: 15000,
            maxLoadTime: 30000,
            timeoutRetryDelay: 2000,
            errorRetryDelay: 3000
          }
        },
        fragLoadingLoadPolicy: { // 片段加载策略
          default: {
            maxTimeToFirstByte: 15000,
            maxLoadTime: 30000,
            timeoutRetryDelay: 2000,
            errorRetryDelay: 3000
          }
        },
        // 启用性能指标收集
        enableStats: true,
        // 优化音视频同步
        avBufferOffset: 0.1,
        maxSeekHole: 2,
        // 优化解码器
        enableCEA708Captions: true,
        enableEMSG: true,
        emeEnabled: false, // 不启用加密媒体扩展
        capLevelOnFPSDrop: false, // 不因帧率下降而限制质量
        capLevelToPlayerSize: false, // 不根据播放器尺寸限制质量
        smoothLiveSegments: true, // 平滑直播片段切换
        allowSeeksWithinDiscontinuities: false, // 避免在不连续处跳跃
        // 启用缓冲区优化
        maxBufferHoleMin: 0.005,
        gapControllerOptions: {
          maxBackBufferLength: 90,
          gapThreshold: 0.5
        },
        // 提前缓冲30秒
        initialLiveManifestSize: 3,
        startPosition: -30 // 开始播放时提前30秒开始（适用于直播）
      };

      // 根据网络质量进一步调整配置
      switch (networkQuality) {
        case 'poor':
          // 网络状况差时，更保守的配置
          baseConfig.maxBufferLength = 30;
          baseConfig.backBufferLength = 10;
          baseConfig.abrBandWidthFactor = 0.5; // 更保守地选择质量
          baseConfig.abrEwmaDefaultEstimate = 2e5; // 200 kbps
          baseConfig.startFragPrefetch = false; // 不预加载第一个片段以节省流量
          baseConfig.fragLoadingMaxRetry = 15;
          baseConfig.levelLoadingMaxRetry = 15;
          break;
        case 'moderate':
          // 中等网络状况
          baseConfig.maxBufferLength = 60;
          baseConfig.backBufferLength = 20;
          baseConfig.abrBandWidthFactor = 0.7;
          baseConfig.abrEwmaDefaultEstimate = 5e5; // 500 kbps
          baseConfig.startFragPrefetch = true;
          baseConfig.fragLoadingMaxRetry = 10;
          baseConfig.levelLoadingMaxRetry = 10;
          break;
        case 'good':
          // 良好网络状况
          baseConfig.maxBufferLength = 90;
          baseConfig.backBufferLength = 30;
          baseConfig.abrBandWidthFactor = 0.9;
          baseConfig.abrEwmaDefaultEstimate = 1.5e6; // 1.5 Mbps
          baseConfig.startFragPrefetch = true;
          baseConfig.fragLoadingMaxRetry = 6;
          baseConfig.levelLoadingMaxRetry = 6;
          break;
      }

      return baseConfig;
    }

    // 申请屏幕唤醒锁
    async function requestWakeLock() {
      if ('wakeLock' in navigator) {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release', () => {

          });
        } catch (err) {
          // 无法申请屏幕唤醒锁
        }
      } else {

      }
    }

    // 释放屏幕唤醒锁
    function releaseWakeLock() {
      if (wakeLock) {
        wakeLock.release();
        wakeLock = null;
      }
    }

    // 页面可见性变化时处理唤醒锁
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // 页面隐藏时释放唤醒锁
        releaseWakeLock();
      } else if (!video.paused && isLoaded) {
        // 页面可见且视频播放时重新申请唤醒锁
        requestWakeLock();
      }
    });

    const fmt = s => {
      if (!s || isNaN(s)) return "0:00";
      const h = Math.floor(s / 3600), m = Math.floor((s % 3600) / 60), r = Math.floor(s % 60);
      return h > 0 ? `${h}:${m < 10 ? '0' + m : m}:${r < 10 ? '0' + r : r}` : `${m}:${r < 10 ? '0' + r : r}`;
    };

    function updateVolUI() {
      const v = video.volume, m = video.muted;
      const vIcon = $('vIcon');
      if (m || v === 0) {
        vIcon.innerHTML = '<path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.39-.81.62-1.72.62-2.7 0-3.17-2.11-5.85-5-6.71v2.06c1.38.86 2.31 2.36 2.31 4.1s-.93 3.24-2.31 4.1v2.06c2.89-.86 5-3.54 5-6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.52.52-.89 1.15-1.14 1.83h2.06c.13-.27.33-.52.58-.77l.01-.01L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>';
      } else if (v > 0.5) {
        vIcon.innerHTML = '<path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>';
      } else {
        vIcon.innerHTML = '<path d="M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 9v6h4l5 5V4L9 9H5z"/>';
      }
      volSlider.value = m ? 0 : v;
    }

    async function playNext(keyword = "") {
      const loader = $('loader');
      loader.classList.remove('hidden');
      try {
        let url = "";
        const isSearch = keyword && keyword.trim() !== "";
        if (isSearch) {
          url = `miss-search.php?title=${encodeURIComponent(keyword.trim())}`;
        } else {
          url = `${API}?exclude=${usedCodes.join(',')}`;
        }

        // 添加超时控制
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000);

        const res = await fetch(url, {
          signal: controller.signal,
          method: 'GET',
          mode: 'cors',
          headers: {
            'Accept': 'application/json'
          }
        });

        clearTimeout(timeoutId);

        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }

        const json = await res.json();
        let listData = [];
        if (isSearch) {
          if (json.success && Array.isArray(json.data)) listData = json.data;
          else if (Array.isArray(json)) listData = json;
          else throw new Error('Invalid response format');
        } else {
          if (json.m3u8 || json.m3u8_url) listData = [json];
        }

        if (listData.length > 0) {
          resultsList.innerHTML = '';
          listData.forEach(item => {
            const div = document.createElement('div');
            div.className = 'result-item';
            const title = item.title || item.name || "未知视频";
            const m3u8 = item.m3u8_url || item.m3u8;
            if (isSearch) {
              const regex = new RegExp(`(${keyword})`, 'gi');
              div.innerHTML = title.replace(regex, '<b>$1</b>');
            } else {
              div.innerText = title;
            }
            div.onclick = (e) => {
              e.stopPropagation();
              startVideo(m3u8, title);
              resultsList.style.display = 'none';
              searchInput.value = '';
            };
            resultsList.appendChild(div);
          });
          if (isSearch) resultsList.style.display = 'block';
          else if (!isSearch && listData.length === 1) startVideo(listData[0].m3u8_url || listData[0].m3u8, listData[0].title || listData[0].name);
        } else if (isSearch) {
          resultsList.innerHTML = '<div class="result-item">未找到相关视频</div>';
          resultsList.style.display = 'block';
        } else {

        }
      } catch (e) {

        // 详细的错误处理
        let errorMessage = "加载失败";
        if (e.name === 'AbortError') {
          errorMessage = "请求超时，请检查网络连接";
        } else if (e.message.includes('Failed to fetch')) {
          errorMessage = "网络连接失败，请检查网络设置";
        } else if (e.message.includes('CORS')) {
          errorMessage = "跨域请求被阻止，请使用代理或检查服务器配置";
        } else {
          errorMessage = e.message;
        }

        if (!keyword) {
          alert(errorMessage);
        } else {
          resultsList.innerHTML = `<div class="result-item">${errorMessage}</div>`;
          resultsList.style.display = 'block';
        }
      } finally {
        loader.classList.add('hidden');
      }
    }

    function startVideo(m3u8, name, auto = true) {
      if (!m3u8) return;
      if (hls) hls.destroy();
      isLoaded = true;
      $('videoTitle').innerText = (name || "VIDEO").split('_')[0].toUpperCase();
      let finalUrl = m3u8.replace("https://surrit.com/", "/s1/");

      // 创建基于URL的唯一ID用于存储播放历史
      const videoId = generateVideoId(m3u8);

      // 获取当前网络状况并配置HLS参数
      const networkQuality = getNetworkQuality();
      // 获取基础配置
      const baseHlsConfig = getHlsConfigForNetwork(networkQuality);
      
      // 增强缓冲区和错误处理配置
      const hlsConfig = {
        ...baseHlsConfig,
        // 专门针对缓冲停滞错误的配置
        maxBufferHole: 0.01,           // 最小缓冲间隙
        maxSeekHole: 2,               // 寻找时的最大间隙
        highBufferWatchdogPeriod: 2,  // 高缓冲监控周期
        gapControllerOptions: {
          maxBackBufferLength: 90,    // 最大后缓冲长度
          gapThreshold: 0.1           // 间隙阈值
        },
        // 错误恢复配置
        nudgeOffset: 0.05,            // 微调偏移量
        nudgeMaxRetry: 10,            // 微调最大重试次数
        maxFragLookUpTolerance: 0.02, // 片段查找容差
        abrBandWidthFactor: 0.7,      // 带宽使用因子
        abrBandWidthUpFactor: 0.8,    // 带宽上调因子
      };

      const setup = () => {
        video.volume = volSlider.value;
        video.muted = true; // 确保每次加载视频时都是静音状态
        updateVolUI();

        // 移动端性能优化
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');

        // 尝试从本地存储恢复播放位置
        const history = JSON.parse(localStorage.getItem('video_history') || '{}');
        if (history[videoId]) {
          // 检查视频是否接近结尾，如果是则从头开始播放
          const savedPosition = history[videoId];
          if (video.duration && savedPosition > video.duration - 10) {
            video.currentTime = 0; // 如果距离结尾不到10秒，则从头开始
          } else {
            video.currentTime = savedPosition;
          }
        }

        // 监听元数据加载完成事件，此时可以获取准确的持续时间
        if (Hls.isSupported()) {
          // 在HLS模式下，我们监听LEVEL_LOADED事件来确认已缓存足够内容
          hls.on(Hls.Events.LEVEL_LOADED, () => {
            // 预缓存30秒内容
            preloadTimeRange(30);
          });

          // 监听缓冲区更新事件，持续确保有足够的预加载内容
          hls.on(Hls.Events.BUFFER_APPENDED, () => {
            preloadTimeRange(30);
          });
        } else {
          // 对于原生视频，直接尝试预缓存
          video.addEventListener('loadeddata', () => {
            preloadTimeRange(30);
          });

          // 监听时间更新，确保缓冲区充足
          video.addEventListener('timeupdate', () => {
            preloadTimeRange(30);
          });
        }

        if (auto) {
          // 移动端优化：先静音播放以绕过自动播放限制
          video.muted = true;
          updateVolUI();
          const playPromise = video.play();
          if (playPromise !== undefined) {
            playPromise
              .then(() => {
                // 播放成功
                $('centerPlayIcon').classList.add('hidden');
                // 如果用户之前设置了非静音，则恢复音量
                setTimeout(() => {
                  if (!video.muted && video.volume > 0) {
                    video.muted = false;
                  }
                }, 1000);
              })
              .catch(error => {
                // 如果自动播放失败，尝试先静音再播放
                video.muted = true;
                updateVolUI();
                video.play().then(() => {
                  $('centerPlayIcon').classList.add('hidden');
                }).catch(() => {
                  // 如果仍然失败，显示播放按钮
                  $('centerPlayIcon').classList.remove('hidden');
                });
              });
          }
        }
      };

      // 预缓存指定时间段的函数
      function preloadTimeRange(secondsToPreload) {
        // 这个函数用于确保指定秒数的内容已被缓冲
        if (video.readyState >= 1 && video.buffered.length > 0) { // HAVE_METADATA及以上
          try {
            const bufferedEnd = video.buffered.end(video.buffered.length - 1);
            const targetTime = Math.min(video.duration || Infinity, video.currentTime + secondsToPreload);

            // 如果缓冲区未达到目标时间，则继续加载
            if (bufferedEnd < targetTime) {
              // 对于HLS.js，通过调整配置可以实现更好的缓冲
              // 这里可以动态调整缓冲区大小
              if (hls) {
                // 确保HLS.js配置中的缓冲区设置生效
                if (hls.config.maxBufferLength < secondsToPreload + 30) {
                  hls.config.maxBufferLength = secondsToPreload + 30;
                }
              }
            }
            
            // 计算当前缓冲进度并更新界面
            const bufferedStart = video.buffered.start(0);
            const totalBuffered = bufferedEnd - bufferedStart;
            const duration = video.duration || 1;
            const bufferPercent = Math.min(100, (totalBuffered / duration) * 100);
            
            // 更新缓冲条
            if (buf && bar && wrap) {
              buf.style.width = bufferPercent + "%";
            }
          } catch (e) {
            // 处理可能的错误，例如在视频加载初期buffered.end可能不可用
            console.warn("Error calculating buffer range:", e);
          }
        }
      }

      // 生成视频的唯一ID用于存储播放历史
      function generateVideoId(url) {
        // 简单的哈希函数生成唯一ID
        let hash = 0;
        for (let i = 0; i < url.length; i++) {
          const char = url.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash |= 0; // 转换为32位整数
        }
        return url.length + '_' + Math.abs(hash).toString(36);
      }

      if (Hls.isSupported()) {
        hls = new Hls(hlsConfig);
        
        // 添加错误处理
        hls.on(Hls.Events.ERROR, function (event, data) {
          console.error('HLS Error:', data);
          
          // 检查是否正在恢复中，避免重复处理
          if (data.details === 'bufferStalledError') {
            console.log('Buffer stalled, attempting recovery...');
            // 对于缓冲停滞错误，尝试降低质量等级
            if (hls && hls.nextLoadLevel > 0) {
              hls.nextLoadLevel = Math.max(0, hls.nextLoadLevel - 1);
            }
            // 增加缓冲区大小以应对停滞
            if (hls) {
              hls.config.maxBufferLength = Math.min(hls.config.maxBufferLength + 30, 180);
            }
            return;
          }
          
          switch (data.type) {
            case Hls.ErrorTypes.NETWORK_ERROR:
              console.log('Network error, trying to recover...');
              // 根据错误类型进行不同的恢复策略
              if (data.details === Hls.ErrorDetails.MANIFEST_LOAD_ERROR ||
                  data.details === Hls.ErrorDetails.MANIFEST_LOAD_TIMEOUT) {
                // 如果是清单加载错误，尝试重试或加载备用源
                setTimeout(() => {
                  if (hls) {
                    hls.startLoad();
                  }
                }, 3000);
              } else {
                // 其他网络错误，尝试恢复
                hls.recoverMediaError();
              }
              break;
            case Hls.ErrorTypes.MEDIA_ERROR:
              console.log('Media error, trying to recover...');
              if (!data.fatal) {
                // 非致命错误，尝试恢复
                hls.recoverMediaError();
              } else {
                // 致命错误，重启播放
                console.log('Fatal media error, restarting stream...');
                hls.destroy();
                setTimeout(() => {
                  startVideo(m3u8, name, auto);
                }, 3000);
              }
              break;
            default:
              // 未知错误类型，尝试重启
              if (data.fatal) {
                console.log('Fatal error, restarting stream...');
                hls.destroy();
                setTimeout(() => {
                  startVideo(m3u8, name, auto);
                }, 3000);
              }
              break;
          }
        });
        
        // 添加性能监控
        hls.on(Hls.Events.FRAG_BUFFERED, function (event, data) {
          // 监控片段缓冲情况
          const stats = hls.stats;
          if (stats) {
            console.debug('Buffered fragment:', {
              size: data.stats.total,
              loading: data.stats.loading.end - data.stats.loading.start,
              parsing: data.stats.parsing.end - data.stats.parsing.start,
              buffering: data.stats.buffering.end - data.stats.buffering.start
            });
          }
          
          // 检查缓冲区状态，防止缓冲停滞
          if (video && video.buffered) {
            try {
              const buffered = video.buffered;
              if (buffered.length > 0) {
                const bufferedEnd = buffered.end(buffered.length - 1);
                const currentTime = video.currentTime;
                
                // 如果缓冲区与当前播放位置差距过大，调整缓冲策略
                if (bufferedEnd - currentTime < 10) { // 如果缓冲不足10秒
                  if (hls) {
                    // 临时增加缓冲区长度
                    hls.config.maxBufferLength = Math.min(hls.config.maxBufferLength + 10, 180);
                  }
                }
              }
            } catch (e) {
              console.warn('Error checking buffer status:', e);
            }
          }
        });
        
        // 监听缓冲区更新事件，持续确保有足够的预加载内容
        hls.on(Hls.Events.BUFFER_APPENDED, function (event, data) {
          // 检查缓冲区状态
          if (video && video.buffered) {
            try {
              const buffered = video.buffered;
              if (buffered.length > 0) {
                const bufferedEnd = buffered.end(buffered.length - 1);
                const duration = video.duration || Infinity;
                const targetBufferEnd = Math.min(duration, video.currentTime + 30); // 目标缓冲30秒
                
                // 如果缓冲区未达到目标时间，则调整配置
                if (bufferedEnd < targetBufferEnd) {
                  if (hls && hls.config.maxBufferLength < 60) {
                    hls.config.maxBufferLength = Math.min(60, duration); // 增加缓冲区大小
                  }
                }
              }
            } catch (e) {
              console.warn('Error in BUFFER_APPENDED handler:', e);
            }
          }
        });
        
        // 监听缓冲区创建事件
        hls.on(Hls.Events.BUFFER_CREATED, function (event, data) {
          console.debug('Buffer created');
        });
        
        // 监听缓冲区清空事件
        hls.on(Hls.Events.BUFFER_FLUSHED, function (event, data) {
          console.debug('Buffer flushed');
          // 缓冲区被清空时，可能需要调整策略
          if (hls) {
            hls.config.maxBufferLength = Math.max(hls.config.maxBufferLength, 30);
          }
        });
        
        
        
        // 监控级别变化
        hls.on(Hls.Events.LEVEL_SWITCHED, function (event, data) {
          console.debug('Level switched to:', data.level);
        });
        
        hls.loadSource(finalUrl);
        hls.attachMedia(video);
        
        // 定期检查缓冲区健康状态的函数
        let bufferHealthCheckInterval = null;
        
        const checkBufferHealth = () => {
          if (!video || !hls) return;
          
          try {
            const buffered = video.buffered;
            const currentTime = video.currentTime;
            const duration = video.duration || Infinity;
            
            if (buffered.length > 0) {
              const bufferedEnd = buffered.end(buffered.length - 1);
              const timeUntilEnd = duration - currentTime;
              
              // 检查当前播放位置是否有足够的缓冲
              const bufferAhead = bufferedEnd - currentTime;
              
              // 如果缓冲不足且不是在播放末尾
              if (bufferAhead < 10 && timeUntilEnd > 10) {
                // 动态调整缓冲区长度
                if (hls.config) {
                  hls.config.maxBufferLength = Math.min(hls.config.maxBufferLength + 15, 180);
                }
              }
              
              // 如果缓冲过多，适当减少以节省内存
              if (bufferAhead > 90) {
                if (hls.config) {
                  hls.config.maxBufferLength = Math.max(hls.config.maxBufferLength - 15, 30);
                }
              }
            }
            
            // 检查播放状态是否正常
            if (!video.paused && video.readyState < 2) { // HAVE_CURRENT_DATA
              // 如果正在播放但没有足够数据，可能需要采取措施
              console.debug('Video playback may be stalled, readyState:', video.readyState);
            }
            
          } catch (e) {
            console.warn('Error in buffer health check:', e);
          }
        };
        
        // 在MANIFEST_PARSED后启动健康检查
        hls.on(Hls.Events.MANIFEST_PARSED, function() {
          // 启动缓冲区健康检查定时器
          if (bufferHealthCheckInterval) {
            clearInterval(bufferHealthCheckInterval);
          }
          bufferHealthCheckInterval = setInterval(checkBufferHealth, 5000); // 每5秒检查一次
          
          // 执行setup函数
          setup();
        });
        
        // 监听播放器销毁事件，清理定时器
        hls.on(Hls.Events.DESTROYING, function() {
          if (bufferHealthCheckInterval) {
            clearInterval(bufferHealthCheckInterval);
            bufferHealthCheckInterval = null;
          }
        });
      } else {
        video.src = finalUrl;
        video.onloadedmetadata = setup;
        
        // 为原生播放器添加错误处理
        video.addEventListener('error', function(e) {
          console.error('Video element error:', e);
          // 尝试重新加载
          setTimeout(() => {
            if (video.networkState === HTMLMediaElement.NETWORK_NO_SOURCE) {
              video.src = finalUrl;
            }
          }, 3000);
        });
      }
      localStorage.setItem('current_video', JSON.stringify({ m3u8, name, videoId }));
    }

    let wrapRect = null;

    const handleProgress = (e, isFinal = false) => {
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const p = Math.max(0, Math.min(1, (clientX - wrapRect.left) / wrapRect.width));
      bar.style.width = (p * 100) + "%";
      if (isFinal) video.currentTime = p * video.duration;
    };

    wrap.onmousedown = (e) => {
      e.preventDefault();  // 防止默认行为
      isDragging = true;
      wrapRect = wrap.getBoundingClientRect();
      handleProgress(e);
    };

    window.onmousemove = (e) => {
      if (isDragging) {
        e.preventDefault();  // 防止拖拽过程中的默认行为
        handleProgress(e);
      }
    };

    window.onmouseup = (e) => {
      if (isDragging) {
        isDragging = false;
        handleProgress(e, true);
      }
    };

    wrap.ontouchstart = (e) => {
      e.preventDefault();  // 防止触摸默认行为
      isDragging = true;
      wrapRect = wrap.getBoundingClientRect();
      handleProgress(e);
    };

    wrap.ontouchmove = (e) => {
      if (isDragging) {
        e.preventDefault();
        e.stopPropagation();
        handleProgress(e);
      }
    };

    wrap.ontouchend = (e) => {
      if (isDragging) {
        isDragging = false;
        handleProgress(e, true);
      }
    };

    video.ontimeupdate = () => {
      // 保存播放历史
      const currentVideo = localStorage.getItem('current_video');
      if (currentVideo && !isDragging) {
        try {
          const data = JSON.parse(currentVideo);
          const history = JSON.parse(localStorage.getItem('video_history') || '{}');
          // 使用视频ID作为键，而不是原始URL
          history[data.videoId] = video.currentTime;

          // 如果视频播放完毕（接近结尾），则从历史记录中移除
          if (video.duration && video.currentTime > video.duration - 5) {
            delete history[data.videoId]; // 播放完毕后清除历史记录
          }

          localStorage.setItem('video_history', JSON.stringify(history));
        } catch (e) {

        }
      }
    };

    video.onplaying = () => {
      $('pIcon').innerHTML = '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>';
      $('centerPlayIcon').classList.add('hidden');
      // 视频播放时申请屏幕唤醒锁
      requestWakeLock();
      const up = () => {
        if (!video.paused && !isDragging) {
          if (video.duration && video.duration > 0) {
            bar.style.width = (video.currentTime / video.duration * 100) + "%";
            if (video.buffered.length) buf.style.width = (video.buffered.end(video.buffered.length - 1) / video.duration * 100) + "%";
          } else {
            bar.style.width = "0%";
            buf.style.width = "0%";
          }
          $('timeBox').innerText = `${fmt(video.currentTime)} / ${fmt(video.duration)}`;
          requestAnimationFrame(up);
        }
      };
      up();
    };

    video.onpause = () => {
      if (isLoaded) $('centerPlayIcon').classList.remove('hidden');
      $('pIcon').innerHTML = '<path d="M8 5v14l11-7z"/>';
      // 视频暂停时释放屏幕唤醒锁
      releaseWakeLock();
    };

    video.onended = () => {
      // 视频结束时释放屏幕唤醒锁
      releaseWakeLock();

      // 从播放历史中清除当前视频的记录
      const currentVideo = localStorage.getItem('current_video');
      if (currentVideo) {
        const data = JSON.parse(currentVideo);
        const history = JSON.parse(localStorage.getItem('video_history') || '{}');
        delete history[data.videoId]; // 播放结束后清除历史记录
        localStorage.setItem('video_history', JSON.stringify(history));
      }
      
      // 清理缓冲区健康检查定时器
      if (bufferHealthCheckInterval) {
        clearInterval(bufferHealthCheckInterval);
        bufferHealthCheckInterval = null;
      }

      playNext();
    };

    $('screen').onclick = () => isLoaded ? (video.paused ? video.play() : video.pause()) : playNext();
    $('playBtn').onclick = () => isLoaded ? (video.paused ? video.play() : video.pause()) : playNext();
    $('nextBtn').onclick = () => playNext();
    $('speedBtn').onclick = (e) => { e.stopPropagation(); $('speedMenu').classList.toggle('show'); };
    $('pipBtn').onclick = async () => {
      try {
        await video.requestPictureInPicture();
      } catch (error) {

      }
    };

    // 修复 iOS 全屏
    $('fullBtn').onclick = () => {
      const node = $('playerNode');
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else if (video.webkitEnterFullscreen) {
        // iOS iPhone 专用
        video.webkitEnterFullscreen();
      } else if (node.requestFullscreen) {
        node.requestFullscreen();
      } else if (node.webkitRequestFullscreen) {
        node.webkitRequestFullscreen();
      }
    };

    // 检测是否为 iOS 设备
    function isIOSDevice() {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) ||
        (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1); // 支持 iPadOS
    }

    // 全屏状态变化事件监听
    document.addEventListener('fullscreenchange', () => {
      const playerNode = $('playerNode');

      if (document.fullscreenElement) {
        // 进入全屏
        playerNode.classList.add('fullscreen');
      } else {
        // 退出全屏
        playerNode.classList.remove('fullscreen');
      }
    });

    volSlider.oninput = (e) => { video.volume = e.target.value; video.muted = (video.volume === 0); updateVolUI(); };
    volBtn.onclick = () => { video.muted = !video.muted; updateVolUI(); };

    document.querySelectorAll('.speed-item').forEach(i => {
      i.onclick = (e) => {
        e.stopPropagation(); video.playbackRate = parseFloat(i.dataset.val);
        $('speedBtn').innerText = i.dataset.val + 'x';
        document.querySelectorAll('.speed-item').forEach(el => el.classList.remove('active'));
        i.classList.add('active'); $('speedMenu').classList.remove('show');
      };
    });

    document.addEventListener('keydown', (e) => {
      if (document.activeElement === searchInput) return;
      const k = e.key;
      if ([' ', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(k)) e.preventDefault();
      if (k === ' ' || k.toLowerCase() === 'k') isLoaded ? (video.paused ? video.play() : video.pause()) : playNext();
      if (k === 'ArrowLeft') seek(-10);
      if (k === 'ArrowRight') seek(10);
      if (k === 'ArrowUp') { video.volume = Math.min(1, video.volume + 0.1); video.muted = false; updateVolUI(); }
      if (k === 'ArrowDown') { video.volume = Math.max(0, video.volume - 0.1); updateVolUI(); }
      if (k.toLowerCase() === 'f') $('fullBtn').click();
      if (k.toLowerCase() === 'm') volBtn.click();
    });
    
    // 防止在拖拽进度条时出现页面缩放
    document.addEventListener('gesturestart', function(e) {
      if (isDragging) {
        e.preventDefault();
      }
    });
    
    document.addEventListener('gesturechange', function(e) {
      if (isDragging) {
        e.preventDefault();
      }
    });
    
    document.addEventListener('gestureend', function(e) {
      if (isDragging) {
        e.preventDefault();
      }
    });

    searchInput.onkeydown = (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        playNext(searchInput.value.trim());
      }
      e.stopPropagation();
    };
    window.seek = s => video.currentTime += s;

    // 页面可见性变化事件监听 - 当用户切换标签页或最小化浏览器时暂停播放
    document.addEventListener('visibilitychange', function () {
      if (document.hidden) {
        // 页面变为不可见（切换到其他标签页、最小化或进入后台）
        if (!video.paused) {
          video.pause();
        }
      }
    });

    // 页面失焦时暂停播放
    window.addEventListener('blur', function () {
      if (!video.paused) {
        video.pause();
      }
    });

    // 页面获得焦点时可以选择恢复播放（可选功能）
    window.addEventListener('focus', function () {
      // 可根据需求决定是否自动恢复播放
      // video.play();
    });

    window.onclick = (e) => {
      if (!e.target.closest('.search-container')) resultsList.style.display = 'none';
      $('speedMenu').classList.remove('show');
    };

    // 自动刷新功能 - 长时间无操作后刷新页面
    let autoRefreshTimer = null;
    const AUTO_REFRESH_TIME = 45 * 60 * 1000; // 45分钟无操作后刷新 (增加了时间间隔)
    
    // 页面活跃状态监测
    let pageActive = true;
    let lastActivityTime = Date.now();

    function resetAutoRefreshTimer() {
      if (autoRefreshTimer) {
        clearTimeout(autoRefreshTimer);
      }
      
      // 更新最后活动时间
      lastActivityTime = Date.now();
      
      autoRefreshTimer = setTimeout(() => {
        const inactiveTime = Date.now() - lastActivityTime;
        if (inactiveTime >= AUTO_REFRESH_TIME) {
          console.log("页面长时间无操作，正在刷新...");
          // 在刷新前清理资源
          if (hls) {
            hls.stopLoad();
            hls.detachMedia();
          }
          location.reload();
        }
      }, AUTO_REFRESH_TIME);
    }

    // 监听用户活动事件
    ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'touchmove', 'click', 'focus', 'blur'].forEach(eventType => {
      document.addEventListener(eventType, resetAutoRefreshTimer, true);
    });

    // 初始化自动刷新计时器
    resetAutoRefreshTimer();
    
    // 定期检查页面状态
    setInterval(() => {
      const currentTime = Date.now();
      const inactiveTime = currentTime - lastActivityTime;
      if (inactiveTime >= AUTO_REFRESH_TIME * 0.8) { // 如果接近刷新时间，显示提醒
        console.log(`页面将在 ${(AUTO_REFRESH_TIME - inactiveTime) / 60000 | 0} 分钟后刷新`);
      }
    }, 60000); // 每分钟检查一次
    
    // 页面卸载前清理资源
    window.addEventListener('beforeunload', function() {
      // 清理缓冲区健康检查定时器
      if (bufferHealthCheckInterval) {
        clearInterval(bufferHealthCheckInterval);
        bufferHealthCheckInterval = null;
      }
      
      // 销毁HLS实例
      if (hls) {
        hls.stopLoad();
        hls.detachMedia();
        hls.destroy();
        hls = null;
      }
    });
    
    // 页面隐藏时清理资源
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        // 页面隐藏时也可以考虑清理一些资源
        if (hls && hls.config) {
          // 可以考虑减小缓冲区以节省内存
          hls.config.maxBufferLength = Math.min(hls.config.maxBufferLength, 30);
        }
      }
    });

    window.onload = () => {
      // 为iOS设备添加特定CSS类
      if (isIOSDevice()) {
        document.body.classList.add('ios-device');
      }

      video.volume = 0.5;
      video.muted = true; // 初始状态静音
      updateVolUI();
      const saved = localStorage.getItem('current_video');
      if (saved) {
        const data = JSON.parse(saved);
        startVideo(data.m3u8, data.name, false);
      } else {
        playNext();
      }
    };
  </script>
</body>

</html>
